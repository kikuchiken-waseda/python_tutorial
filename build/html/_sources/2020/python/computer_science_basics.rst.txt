=====================================================
計算機科学基礎
=====================================================

.. contents:: 目次


What is this
===========================

ここでは, :code:`python` を使った古典的な計算機科学問題に取り組んでいこうと思います.

古典的な計算機問題には例えばナップサック問題というものがあります.
皆様はこれから無人島に島流しに合います.
ここで大きさの決まったナップサックを一つだけ持っていくことができます.
無人島生活には色々なものが必要ですが, ナップサックに入る量は決まっています.
この際に, ある目標の価値を上回る品物の選び方はあるのか, ないのか,
どの組み合わせが最もよいのか, こういうことを決める問題です.

一見すると, あまり面白い問題ではないようにも見えますが (無人島にナップザック一個
で行くとかそうそうない, どうぶつの森でもあるまいし...), この問題は色々な所で使え
ます. 例えば, 年度の頭には予算決めがあるのですが, 限られた予算で欲しいものを最大
幸福的に受け取る計画を立てるなんて, よくある話です.

あるいは限られた時間の中で, どの講義には力を入れ, どの講義は手を抜く(切る)のかな
んて皆様も一度は考えたことがあるのではないでしょうか?

世の中には典型的というか、よく出くわす問題 (先程の予算のように)というものがある
のです. こうしたよくある問題をパズルの問題のようにしたものが古典的な計算機科学の
問題です. そして, 世のパズルがそうであるように, これらの問題には定石というか,
一般的な解法というものも存在します.
こういう一般的な解法のことを, かっこよく言えばアルゴリズムというのです.

計算機科学とは何かいうと要はパズルです. パズル.
最初に頭を使って考えて, 答えに納得したらあとは身に付ければそれでよいと思います.
どうぞ, 気楽に楽しんでみてください.

For whom?
===========================

この文章の中では然程 :code:`python` そのものに関しての説明を記述しません.
それは :doc:`/2019/python/first` で既に行っています.
それ以上の知識は不要です.

逆に,  上記チュートリアルをまだ行っていない場合には,
必ず一読しておいてください.

準備運動
===========================

フィボナッチ数列
-----------------------

まずは準備運動として `フィボナッチ数列 <https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0>`_ を解いてみましょう.
もしかしたら少しプログラミングに詳しい人にはお馴染の問題かも知れません.

ここで考え、慣れて欲しいことは以下の二つです.

1. 数式が与えられた時にそれをプログラムに直す練習(あと関数の復習)
2. 再帰処理の発想と練習

フィボナッチ数列とは, 先頭の2項 (二つの数字) を除いて, 一般項が前の 2 項の和で示されます.

... 何を言っているのでしょう.

まずは例で考えます.

以下の数列はフィボナッチ数列です::

    0, 1, 1, 2, 3, 5, 8 ...

まず, 第一項のフィボナッチ数は 0 です.
で, 次の項は 1 ですね.

第三項はというと, 第一項と第二項の和なので, 1 です.
以下, 第四項は第二項と第三項の和なので 2 です.
では, ... で省略した次の項はなんでしょう(考えてみてください. 勿論 SLACK で皆様答え合わせしてくれてもいいですよ)?

さて, この数列の任意の n 項目のフィボナッチ数は次式で得られます.

.. math::

    F_0 &= 0, \\
    F_1 &= 1, \\
    F_n &= F_{n - 1} + F_{n - 2} (n  \gt 2)

数式の意味としては, フィボナッチ数列の第一項が 0 で, 第二項が 1 の時に,
2 より大きい n は n の一個前の場合の値と, 二個前の場合の値の和で決まると書いてあります.
言い換えれば, 先頭の2項 (二つの数字) を除いて, 一般項が前の 2 項の和で 第 n 項示のフィボナッチ数列が表現されるということですから,
実は定義をそのまま、数式にしたにすぎません.

再帰処理
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

なぜ, 言葉の通りの内容を態々小難しい数式なんぞに変えたかというと,
一度数式にすると, そのままコードに変換することができるからです.

ちょっとコードに書いてみましょう::

    def fib(n):
        return fib(n - 1) + fib(n - 2)

ほらね, そのままでしょ?

え, これで動くの? のビックリされた貴方.
試してみてください::

    def fib(n):
        return fib(n - 1) + fib(n - 2)

    print(fib(3))

安心してください. 当然動きません.
エラーがでますね.

そのエラーをよく読んでください.
以下のようになっているはずです::

    RecursionError: maximum recursion depth exceeded

直訳すると, "'最大再帰深度を超えました" です.
今回のテーマである "再帰" という言葉がでましたね.

上記コードの問題は, 常に :code:`fib` 関数が呼ばれ続けてしまうため,
いつまで立っても計算が終わらないことです
(こういうものを無限再帰と呼びます. 大まかには無限ループのようなものだと思ってくれて構いません).

要は計算ができないのではなく、計算が終わらないことが問題なのです.
そのため、終了条件(基底部, 計算を終えるための条件)を用意してやれば,
上記関数は上手く動きます.

では :code:`fib` の基底部はなんでしょうか?
これも実は数式では定義されています.
そう, 最初の二項を除いて... の部分です.

素直にコードを書くと以下のようになります::

    def fib(n):
        if n < 2:  # 最初の二項では
            return n  # そのまま n を返す
        return fib(n - 1) + fib(n - 2)  # それ以外では再帰的に自身を呼び出す

    print([fib(n) for n in range(7)])

このコードを実行すると冒頭で示したフィボナッチ数列がそのまま得られます(内包表記, 覚えていますか?).

その次の値の答え合わせもできますね.

さて, この再帰式, とっても面白い形をしていませんか?
書いてあることは :code:`if` 文なのにやっていることは :code:`for` 文です.
:doc:`/2019/python/first` の中でチラッと, "制御構文の多くはこの :code:`if` 文から作成されています" と書いていますが,
実は繰り返し系の制御構文は :code:`if` 文で作成することができるのです.

計算時間
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

もう少し, この再帰について教えると,
フィボナッチ数列の様な数式のことを数学の言葉では 漸化式 といいます.
これは, 逆に言えば漸化式と言われれば、再帰を書けばとりあえず関数が作れるということを意味します.
例えば、デジタル信号処理なんかでは、この漸化式は非常に良く出てきますし、
最適化、機械学習などの実装にもこれはよく使います.

さて、先に作成した :code:`fib` 関数に話を戻します.
この :code:`fib` 関数には実は問題があるのです.

たとえば n = 35 のフィボナッチ数を計算させてみてください.
大分時間がかかるはずです.

では n = 50 だったら?

多分計算が終わらないでしょう.

これは何故かわかりますか?

ここには再帰の呼出し回数が関わってきます.
たとえば, :code:`fib(4)` の場合の呼出を考えてみると以下の通りです::

    fib(4) -> fib(3) + fib(2)
           -> fib(3) -> fib(2) + fib(1)
                     -> fib(2) -> fib(1) + fib(0)
                               -> fib(1) -> 1
                               -> fib(0) -> 0
           -> fib(2) -> fib(1) + fib(0)
                     -> fib(1) -> 1
                     -> fib(0) -> 0

このように n=4 のときには :code:`fib` 関数は 9 回呼び出されます.
では n=5 では何回でしょう. n=10 では?
この二つ位は頑張って数えてみましょうか (まだ 1000 は行かないので).

n = 20 くらいになると 20000 回を超える呼出し回数になります.
これだけぐるぐると繰り返し処理をしていると, 計算が中々終わりません(n=50 くらいになると多分まず, 終わらないんじゃないかな?)

では, n = 50 際のフィボナッチ数は計算できないのか？
というと, 実はそんなことはありません.

この節の最後には、 n = 50 の場合のフィボナッチ数を計算するための方法を二種類紹介します.

メモ化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一つの方法はメモ化です.
もう一度フィボナッチ数列を眺めてみましょう::

    0, 1, 1, 2, 3, 5, 8 ...

我々人間はこの数列をみれば次の値は直ぐにわかりますね.
なんで、直ぐに分かるかというとその前の結果を記録して覚えておくことができるからです.

同じようにプログラムでも前の結果を記録させて置けば処理は大分早くなります。
このように前の処理結果を保存しておいて、必要になった時に保存された結果を使う技法をメモ化といいます.

早速メモ化を試してみましょう::

    memo = {0:0, 1:1}  # 基底部

    def fib(n):
        if n  not in memo:
          memo[n] = fib(n - 1) + fib(n - 2)
        return memo[n]

    print([fib(n) for n in range(7)])
    print(fib(50))

このようにするとさっきまで何時迄立っても結果が出なかった :code:`fib(50)` が一瞬で出てきます.

上のコードでは関数の外に変数 :code:`memo` を用意します.
今回は辞書型(覚えています？)で値を決めています.

.. note:: 何故 dict 型なのか?

   変数 :code:`memo` は別に dict 型である必要はありません.
   list でも問題なく作ることが可能です(チャレンジしてみてください).

   なぜ dict 型を選んだかというと key = n, value = 解答 の形でメモを整理したかったからです.

   ただし 変数 :code:`memo` を宣言する場所は必ず :code:`fib` 関数の外で無くてはいけません。
   何故だかわかりますか？

一番最初に基底部を決めているので,
:code:`if` 文の中では :code:`memo` に解答がない場合だけ, 結果を保存するようにすればよいです.
この処理をすると、どのような場合でも :code:`memo` の中には解答が記録されているので、
あとはそのまま、  :code:`memo` の情報を返せば関数は上手く動きます.


.. note:: メモ化をもっと楽にする

   上記メモ化のコードは内容がとても分かり易いですが少し面倒です.
   python という言語は簡単なことを簡単にやるのが好きな言語なので、
   メモ化そのものはもっと手軽に実行できます::

      from functools import lru_cache

      @lru_cache(maxsize=None)
      def fib(n):
          if n < 2:
              return n
          return fib(n - 1) + fib(n - 2)

      print(fib(50))

   上記コードでは関数の内容そのものはメモ化をする前のものと同一です
   ( :code:`fib` 関数が何をやるのかはこちらの方が分かり易いでしょう)
   ただ, 上で少し不思議なことをしています.

   まず一行目ではライブラリの読み込みを行っています.
   ここで使用している :code:`functools` というライブラリは python が元々持っている便利ツールの一つです.
   このツールの内,  :code:`lru_cache` という関数を使いますよというのが、
   一行目の意味です.

   @ を使う記法は今回はじめて出てきましたね.
   これはデコレーターといいます(ほら、ケータイをデコるとかいうじゃないですか、あのデコです).

   少し言葉の説明になりますが, 例えばケータイをデコるといったとき(通じる？)、
   シールをはるのはデコるですよね.
   でも, 例えばなかのSIMカードを変えることをデコるとは余り言わないかと思います.

   何がいいたいかというと、デコレータ, デコレーションという言葉は
   何かに被せるとか, 上にのせるとかそういう行為をさしていて,
   本体を変えるものじゃないということです(別のプログラミング用語としてラッパーという言い方をすることもあります).

   同じように, :code:`@lru_cache` 関数も, :code:`fib` 関数を覆います.
   つまり, :code:`fib` 関数実行時に入力を監視して, もし計算したことがあれば、
   その結果を返し、計算したことが無い場合だけ, 実際に :code:`fib` 関数を実施します.
   また, :code:`fib` 関数が実行された際には自動でその結果を保存します.
   つまり, :code:`fib` 関数の開始と終了で何か決まった処理を行うわけです.
   こういう関数のことをデコレータ関数(ラッパー関数)といいます.

   デコレータ関数は自分で書けると凄く便利なので(実務ではよく使うのですよ. 例えば
   ログを取ったり, 計算させた後で可視化をさせたり, 結果はどうあれ何かをしたい時
   というのは往々にしてあるものです), 興味のある方は調べてみるとよいですよ.

   あと, :code:`@lru_cache` に関してですが,  キャッシュという言葉を聞いたことがある方は居ませんか？
   なんか, キャッシュが残って変な結果になっているとか.
   メモ化とは、あのキャッシュを関数レベルで使いましょうという話です.
   特にプログラミングに不慣れな方ほど、キャッシュという言葉、ものを毛嫌いする傾向があるのですが,
   キャッシュを上手く使えると、今迄試したように、計算が終わらないものを一瞬で解決できるようになったりするのです.

反復処理化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

さあ、準備運動第一節で、多分皆様大分お疲れかと思いますが, まだ続きます.

この節の最後に, フィボナッチを反復型(普通の :code:`for` 文)で解いてみましょう::

      def fib(n):
          if n == 0:
              return 0
          last = 0  # 前の値を保存(初期値は fib(0) なので 0 )
          next = 1  # 次の値を保存(初期値は fib(1) なので 1 )
          for _ in range(1, n):
              last, next = next , last + next
          return next

      fib(50)

さあ, これでも答えは出てきます.
そしてメモ化はしていないのに :code:`fib(50)` を計算することができます.

まず, このコードでもフィボナッチの計算が何故できるのか説明できますか？
そして, なぜメモ化をしていないのに再帰で書く場合とは違い答えが出てくるのかわかりますか?

課題として, まずは n = 0 から n = 5 位までで各行の結果がどうなるのかを考えてみてください.
そして、結果として公式通りの処理になっていることを確認してください.

その際に, :code:`for` 文が何回実行されるのかを考えてみるとよいでしょう.

上記二つに解答できたら、この節は終了です(繰り返しですが SLACK 等で答え合わせとかしてもいいですよ)

まとめ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

この節では, 再帰という手法を紹介しました.
この手法を使うと、何か数式(漸化式)が与えられた場合に,
それをコードに変換することがとても簡単にできるようになります.

一方で再帰を使ってしまうと計算回数がとてつもなく多くなってしまう場合もあります.
こういう際には一度, 反復型でコードを書き直してみると計算速度は一気に向上します.

- でも面倒な場合にはメモ化(キャッシュ)を上手く使いましょう.

これがこの節で言いたいことの要約になります.


圧縮
-----------------------

ビット配列

暗号化
-----------------------

ビット演算

円周率
-----------------------

数式のコード化

ハノイの塔
-----------------------

リスト演算

まとめと応用のヒント
-----------------------

練習問題
-----------------------

検索問題
===========================

DNA 検索問題
---------------------------

迷路
---------------------------

宣教師と食人種
---------------------------

実世界での応用
---------------------------

練習問題
---------------------------

制約充足問題
===========================

地図塗り分け問題
---------------------------

8クイーン
---------------------------

単語探し
---------------------------

覆面算
---------------------------

回路レイアウト
---------------------------

実世界での応用
---------------------------

練習問題
---------------------------

グラフ問題
===========================

最短経路問題
---------------------------

コスト最小化問題
---------------------------

最適化問題
---------------------------


遺伝的アルゴリズム
===========================

省略しようかな...

K 平均クラスタリング
===========================

省略しようかな...

ニューラルネット
===========================

省略しようかな...

敵対探索
===========================

三目並べ
---------------------------

コネクトフォー
---------------------------

実世界での応用
---------------------------

練習問題
---------------------------


その他
===========================

ナップザック問題
---------------------------

巡回セールスマン問題
---------------------------

電話番号記憶術(語呂合わせ)
---------------------------

実世界での応用
---------------------------

練習問題
---------------------------
